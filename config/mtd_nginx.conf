# ─────────────────────────────────────────────────────────────
#  NeoVigil MTD Proxy — OpenResty (Nginx + Lua) Configuration
# ─────────────────────────────────────────────────────────────
#  This reverse proxy sits in front of production services and
#  dynamically spoofs server fingerprints for suspicious IPs.
#
#  The Lua hooks read from a JSON rules file populated by the
#  Obfuscation Engine (src/obfuscation_engine.py).
#
#  Key files:
#    /etc/nginx/obfuscation_rules.json   — Active per-IP rules
#    /etc/nginx/obfuscation_profiles.json — Spoof profile library
# ─────────────────────────────────────────────────────────────

# Load obfuscation rules into shared memory on startup
lua_shared_dict obfuscation_rules 10m;
lua_shared_dict mtd_stats 1m;

init_by_lua_block {
    local cjson = require "cjson"

    -- Load obfuscation rules from file into shared dict
    local function load_rules()
        local f = io.open("/etc/nginx/conf.d/obfuscation_rules.json", "r")
        if not f then
            ngx.log(ngx.WARN, "[MTD] No obfuscation_rules.json found")
            return
        end

        local content = f:read("*a")
        f:close()

        local ok, data = pcall(cjson.decode, content)
        if not ok then
            ngx.log(ngx.ERR, "[MTD] Invalid JSON in rules file: ", data)
            return
        end

        local rules = data.rules or {}
        local dict = ngx.shared.obfuscation_rules
        dict:flush_all()

        local count = 0
        for ip, rule in pairs(rules) do
            -- Check TTL
            if rule.expires_at then
                -- Store the full rule as JSON for the header filter
                dict:set(ip, cjson.encode(rule.spoof_config))
                count = count + 1
            end
        end

        ngx.log(ngx.INFO, "[MTD] Loaded ", count, " obfuscation rules")
        ngx.shared.mtd_stats:set("rule_count", count)
        ngx.shared.mtd_stats:set("last_reload", ngx.time())
    end

    load_rules()
}

server {
    listen 80;
    listen 443 ssl;

    # Self-signed cert for development (replace in production)
    ssl_certificate     /etc/nginx/ssl/mtd-proxy.crt;
    ssl_certificate_key /etc/nginx/ssl/mtd-proxy.key;

    server_name _;

    # ─── Hide the real server identity by default ─────────
    server_tokens off;
    more_clear_headers Server;

    # ─── Health check endpoint for MTD Controller ─────────
    location /_mtd/health {
        access_log off;
        content_by_lua_block {
            local cjson = require "cjson"
            local stats = ngx.shared.mtd_stats
            ngx.say(cjson.encode({
                status = "healthy",
                rule_count = stats:get("rule_count") or 0,
                last_reload = stats:get("last_reload") or 0,
                uptime = ngx.time() - (stats:get("start_time") or ngx.time()),
            }))
        }
    }

    # ─── Reload endpoint (called by Obfuscation Engine) ───
    location /_mtd/reload {
        allow 127.0.0.1;
        allow 172.16.0.0/12;
        deny all;

        content_by_lua_block {
            -- Re-read the rules file
            local cjson = require "cjson"
            local f = io.open("/etc/nginx/conf.d/obfuscation_rules.json", "r")
            if not f then
                ngx.status = 404
                ngx.say('{"error": "rules file not found"}')
                return
            end

            local content = f:read("*a")
            f:close()

            local ok, data = pcall(cjson.decode, content)
            if not ok then
                ngx.status = 500
                ngx.say('{"error": "invalid JSON"}')
                return
            end

            local rules = data.rules or {}
            local dict = ngx.shared.obfuscation_rules
            dict:flush_all()

            local count = 0
            for ip, rule in pairs(rules) do
                if rule.spoof_config then
                    dict:set(ip, cjson.encode(rule.spoof_config))
                    count = count + 1
                end
            end

            ngx.shared.mtd_stats:set("rule_count", count)
            ngx.shared.mtd_stats:set("last_reload", ngx.time())

            ngx.say('{"status": "reloaded", "rules_loaded": ' .. count .. '}')
            ngx.log(ngx.INFO, "[MTD] Hot-reloaded ", count, " rules")
        }
    }

    # ─── Statistics endpoint ──────────────────────────────
    location /_mtd/stats {
        allow 127.0.0.1;
        allow 172.16.0.0/12;
        deny all;

        content_by_lua_block {
            local cjson = require "cjson"
            local stats = ngx.shared.mtd_stats
            local rules = ngx.shared.obfuscation_rules

            -- Count spoofed requests
            local spoofed = stats:get("spoofed_count") or 0
            local clean = stats:get("clean_count") or 0

            ngx.say(cjson.encode({
                active_rules = stats:get("rule_count") or 0,
                spoofed_requests = spoofed,
                clean_requests = clean,
                last_reload = stats:get("last_reload") or 0,
            }))
        }
    }

    # ─── Main proxy — all traffic ─────────────────────────
    location / {
        # Log scanner IPs for telemetry
        access_by_lua_block {
            local client_ip = ngx.var.remote_addr
            local rules = ngx.shared.obfuscation_rules
            local rule_json = rules:get(client_ip)

            if rule_json then
                -- Mark this request for header spoofing
                ngx.ctx.spoof_rule = rule_json
                ngx.ctx.is_spoofed = true

                -- Increment stats
                local stats = ngx.shared.mtd_stats
                local count = stats:get("spoofed_count") or 0
                stats:set("spoofed_count", count + 1)

                ngx.log(ngx.INFO,
                    "[MTD] Spoofing response for scanner: ", client_ip)
            else
                local stats = ngx.shared.mtd_stats
                local count = stats:get("clean_count") or 0
                stats:set("clean_count", count + 1)
            end
        }

        # ─── Response header manipulation ─────────────────
        header_filter_by_lua_block {
            if not ngx.ctx.is_spoofed then
                return
            end

            local cjson = require "cjson"
            local ok, profile = pcall(cjson.decode, ngx.ctx.spoof_rule)
            if not ok then
                return
            end

            -- Spoof Server header
            if profile.server_header then
                ngx.header["Server"] = profile.server_header
            end

            -- Spoof X-Powered-By
            if profile.x_powered_by then
                ngx.header["X-Powered-By"] = profile.x_powered_by
            elseif profile.x_powered_by == ngx.null then
                ngx.header["X-Powered-By"] = nil
            end

            -- Remove revealing headers
            if profile.remove_headers then
                for _, h in ipairs(profile.remove_headers) do
                    ngx.header[h] = nil
                end
            end

            -- Add decoy headers
            if profile.add_headers then
                for k, v in pairs(profile.add_headers) do
                    if v == "auto-generate" then
                        -- Generate a realistic-looking value
                        ngx.header[k] = string.format(
                            "%x-%x-%x",
                            math.random(0, 0xFFFF),
                            math.random(0, 0xFFFF),
                            math.random(0, 0xFFFF)
                        )
                    else
                        ngx.header[k] = v
                    end
                end
            end
        }

        # ─── Upstream: configurable per migration ─────────
        # The MTD Controller updates this upstream block during
        # Blue/Green migrations to point to the Green container.
        proxy_pass http://mtd_upstream;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Connection draining support
        proxy_connect_timeout 5s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}

# ─── Default upstream (updated by Migration Engine) ───────
upstream mtd_upstream {
    # Default: forward to production services
    # The Migration Engine updates this block during Blue/Green
    # migration by writing a new upstream config and reloading.
    server opensearch-node:9200;
}
